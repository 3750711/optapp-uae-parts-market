
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { adaptiveClient } from './adaptiveClient';

const SUPABASE_URL = "https://vfiylfljiixqkjfqubyq.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZmaXlsZmxqaWl4cWtqZnF1YnlxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ4OTEwMjUsImV4cCI6MjA2MDQ2NzAyNX0.KZbRSipkwoZDY8pL7GZhzpAQXXjZ0Vise1rXHN8P4W0";

// Создаем статичный fallback клиент
const fallbackClient = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Прокси объект для seamless использования
const supabase = new Proxy({} as any, {
  get(target, prop) {
    if (prop === 'then' || prop === 'catch' || prop === 'finally') {
      // Для await операций возвращаем адаптивный клиент
      return adaptiveClient.getClient().then(client => client)[prop as string];
    }

    // Для остальных операций пытаемся использовать адаптивный клиент синхронно
    try {
      return adaptiveClient.getClient().then(client => {
        const method = client[prop as keyof typeof client];
        if (typeof method === 'function') {
          return method.bind(client);
        }
        return method;
      }).catch(() => {
        // Fallback к статичному клиенту в случае ошибки
        const method = fallbackClient[prop as keyof typeof fallbackClient];
        if (typeof method === 'function') {
          return method.bind(fallbackClient);
        }
        return method;
      });
    } catch {
      // Синхронный fallback
      const method = fallbackClient[prop as keyof typeof fallbackClient];
      if (typeof method === 'function') {
        return method.bind(fallbackClient);
      }
      return method;
    }
  }
});

export { supabase };
