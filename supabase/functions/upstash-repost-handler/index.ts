import { createServiceClient } from '../_shared/client.ts';
import { getLocalTelegramAccounts, getTelegramForDisplay } from "../shared/telegram-config.ts";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// –ò–∑–≤–ª–µ–∫–∞–µ—Ç –Ω–æ–º–µ—Ä –ø—Ä–æ–±–ª–µ–º–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–∑ Telegram –æ—à–∏–±–∫–∏
function parseFailedImageIndex(errorDescription: string): number | null {
  // "Bad Request: failed to send message #3 with the error message \"WEBPAGE_MEDIA_EMPTY\""
  const match = errorDescription.match(/message #(\d+)/);
  return match ? parseInt(match[1], 10) - 1 : null; // -1 —Ç.–∫. Telegram —Å—á–∏—Ç–∞–µ—Ç —Å 1, –º–∞—Å—Å–∏–≤ —Å 0
}

const MAX_RETRIES = 3; // ‚úÖ –£–º–µ–Ω—å—à–µ–Ω–æ —Å 5, —Ç.–∫. —Ç–µ–ø–µ—Ä—å –∂–¥—ë–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª—ã
const TG_BOT_TOKEN = Deno.env.get('TG_BOT_TOKEN');
const TG_CHAT_ID = Deno.env.get('TG_CHAT_ID');

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    // Basic QStash signature check
    const signature = req.headers.get("Upstash-Signature");
    if (!signature) {
      console.error('‚ùå [QStash] Missing signature header');
      return new Response('Unauthorized', { status: 401 });
    }

    const body = await req.text();
    const data = JSON.parse(body);
    const { productId, notificationType = 'repost', priceChanged, newPrice, oldPrice } = data;

    console.log(`üìÆ [QStash] Processing ${notificationType} notification:`, { productId });

    if (!TG_BOT_TOKEN || !TG_CHAT_ID) {
      console.error('‚ùå [QStash] Telegram credentials not configured');
      return new Response(
        JSON.stringify({ error: 'Telegram not configured' }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 500 }
      );
    }

    const supabaseClient = createServiceClient();

    // Get product with images
    const { data: product, error: productError } = await supabaseClient
      .from('products')
      .select(`
        *,
        product_images (url),
        profiles!products_seller_id_fkey (
          opt_id,
          telegram,
          full_name
        )
      `)
      .eq('id', productId)
      .single();

    if (productError || !product) {
      console.error('‚ùå [QStash] Product not found:', productError);
      return new Response(
        JSON.stringify({ error: 'Product not found' }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 404 }
      );
    }

    // === SPECIAL CASE: Sold notification (text-only) ===
    if (notificationType === 'sold') {
      console.log('üìù [QStash] Sending sold notification (text-only)');
      
      const titleParts = [product.title, product.brand, product.model].filter(Boolean);
      const fullTitle = titleParts.join(' ').trim();
      
      const textMessage = `üòî –ñ–∞–ª—å, –Ω–æ –õ–æ—Ç #${product.lot_number} ${fullTitle} —É–∂–µ —É—à–µ–ª!\n–ö—Ç–æ-—Ç–æ –æ–∫–∞–∑–∞–ª—Å—è –±—ã—Å—Ç—Ä–µ–µ... –≤ —Å–ª–µ–¥—É—é—â–∏–π —Ä–∞–∑ –ø–æ–≤–µ–∑–µ—Ç - –±—É–¥—å –Ω–∞—á–µ–∫—É.`;
      
      try {
        const response = await fetch(
          `https://api.telegram.org/bot${TG_BOT_TOKEN}/sendMessage`,
          {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              chat_id: TG_CHAT_ID,
              text: textMessage,
              parse_mode: 'HTML'
            })
          }
        );

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`Telegram API error: ${errorText}`);
        }

        console.log(`‚úÖ [QStash] Sold notification sent successfully for product ${productId}`);
        
        // Update product and log
        await supabaseClient
          .from('products')
          .update({ 
            last_notification_sent_at: new Date().toISOString(),
            telegram_notification_status: 'sent'
          })
          .eq('id', productId);

        await supabaseClient.from('telegram_notifications_log').insert({
          function_name: 'upstash-repost-handler',
          notification_type: 'sold',
          recipient_type: 'group',
          recipient_identifier: TG_CHAT_ID || 'unknown',
          message_text: textMessage,
          status: 'sent',
          related_entity_type: 'product',
          related_entity_id: productId
        });

        return new Response(
          JSON.stringify({ success: true, type: 'sold' }),
          { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        );
      } catch (error) {
        console.error('‚ùå [QStash] Failed to send sold notification:', error);
        
        await supabaseClient.from('telegram_notifications_log').insert({
          function_name: 'upstash-repost-handler',
          notification_type: 'sold',
          recipient_type: 'group',
          recipient_identifier: TG_CHAT_ID || 'unknown',
          message_text: textMessage,
          status: 'failed',
          error_details: { error: error.message },
          related_entity_type: 'product',
          related_entity_id: productId
        });

        return new Response(
          JSON.stringify({ error: error.message }),
          { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 500 }
        );
      }
    }

    // === IMAGE-BASED NOTIFICATIONS (repost, product_published) ===
    
    // Get product images - use original URLs without Cloudinary optimization
    // Telegram performs its own optimization, so additional transformations can cause
    // WEBPAGE_MEDIA_EMPTY errors due to redirects or on-the-fly generation
    const imageUrls = product.product_images?.map(img => img.url) || [];
    console.log(`üì∑ Using ${imageUrls.length} original image URLs for Telegram delivery`);

    // Load local telegram accounts for proper display
    const localTelegramAccounts = await getLocalTelegramAccounts();


    // Validate all image URLs with timeout
    const VALIDATION_TIMEOUT = 3000; // 3 seconds per image
    const validationStart = Date.now();
    const validImageUrls: string[] = [];
    
    for (const url of imageUrls) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), VALIDATION_TIMEOUT);
        
        const response = await fetch(url, { 
          method: 'HEAD',
          signal: controller.signal 
        });
        
        clearTimeout(timeoutId);
        
        if (response.ok) {
          validImageUrls.push(url);
        } else {
          console.warn(`‚ö†Ô∏è [QStash] Invalid image URL (${response.status}): ${url}`);
        }
      } catch (error) {
        if (error.name === 'AbortError') {
          console.warn(`‚ö†Ô∏è [QStash] Image validation timeout (${VALIDATION_TIMEOUT}ms): ${url}`);
        } else {
          console.warn(`‚ö†Ô∏è [QStash] Error validating image URL: ${url}`, error);
        }
      }
    }

    const validationDuration = Date.now() - validationStart;
    console.log(`‚è±Ô∏è [QStash] Validation took ${validationDuration}ms for ${imageUrls.length} images`);

    if (validImageUrls.length === 0) {
      console.error('‚ùå [QStash] No valid images found');
      return new Response(
        JSON.stringify({ error: 'No valid images' }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 400 }
      );
    }

    console.log(`‚úÖ [QStash] Validated ${validImageUrls.length}/${imageUrls.length} images`);

    // –§–æ—Ä–º–∏—Ä—É–µ–º –ø–æ–ª–Ω—ã–π –∑–∞–≥–æ–ª–æ–≤–æ–∫ —Å –±—Ä–µ–Ω–¥–æ–º –∏ –º–æ–¥–µ–ª—å—é
    const titleParts = [
      product.title,
      product.brand,
      product.model
    ].filter(Boolean);
    const fullTitle = titleParts.join(' ').trim();

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–Ω–∏–∂–µ–Ω–∏–µ —Ü–µ–Ω—ã
    const isPriceReduced = priceChanged && newPrice && oldPrice && newPrice < oldPrice;

    // –î–æ–±–∞–≤–ª—è–µ–º ‚ùóÔ∏èSALE‚ùóÔ∏è –∫ –Ω–æ–º–µ—Ä—É –ª–æ—Ç–∞ –ø—Ä–∏ —Å–Ω–∏–∂–µ–Ω–∏–∏ —Ü–µ–Ω—ã
    const lotNumber = isPriceReduced 
      ? `#${product.lot_number}‚ùóÔ∏èSALE‚ùóÔ∏è`
      : `#${product.lot_number}`;

    // –§–æ—Ä–º–∏—Ä—É–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ü–µ–Ω–µ
    const priceInfo = priceChanged && newPrice && oldPrice
      ? `\nüí∞ –ù–æ–≤–∞—è —Ü–µ–Ω–∞: ${newPrice} $ (–±—ã–ª–æ ${oldPrice} $)`
      : `\nüí∞ –¶–µ–Ω–∞: ${product.price} $`;

    // –î–æ–±–∞–≤–ª—è–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ, –µ—Å–ª–∏ –æ–Ω–æ –µ—Å—Ç—å (—Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º –≤ 200 —Å–∏–º–≤–æ–ª–æ–≤)
    const descriptionLine = product.description 
      ? `\nüìù ${product.description.slice(0, 200)}${product.description.length > 200 ? '...' : ''}` 
      : '';

    // Caption –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ç–∏–ø–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
    const statusLine = notificationType === 'product_published' 
      ? '\n\nüìä –°—Ç–∞—Ç—É—Å: –û–ø—É–±–ª–∏–∫–æ–≤–∞–Ω'
      : '\n\nüìä –°—Ç–∞—Ç—É—Å: –û–ø—É–±–ª–∏–∫–æ–≤–∞–Ω';
    
    const caption = `LOT(–ª–æ—Ç) ${lotNumber}\nüì¶ ${fullTitle}${priceInfo}\nüöö –¶–µ–Ω–∞ –¥–æ—Å—Ç–∞–≤–∫–∏: ${product.delivery_price || 0} $\nüÜî OPT_ID –ø—Ä–æ–¥–∞–≤—Ü–∞: ${product.profiles?.opt_id || 'N/A'}\nüë§ Telegram –ø—Ä–æ–¥–∞–≤—Ü–∞: ${getTelegramForDisplay(product.profiles?.telegram || '', localTelegramAccounts)}${descriptionLine}${statusLine}`;

    // Check caption length (Telegram limit is 1024 chars)
    console.log(`üìù [QStash] Caption length: ${caption.length} chars`);
    if (caption.length > 1024) {
      console.warn(`‚ö†Ô∏è [QStash] Caption exceeds Telegram limit (1024 chars), truncating...`);
      const truncatedCaption = caption.substring(0, 1020) + '...';
      console.log(`üìù [QStash] Truncated to: ${truncatedCaption.length} chars`);
    }

    // Send to Telegram with retry logic
    let lastError: any = null;
    let lastRetryAfter = 0; // ‚úÖ –°–æ—Ö—Ä–∞–Ω—è–µ–º retry_after –º–µ–∂–¥—É –ø–æ–ø—ã—Ç–∫–∞–º–∏
    
    // ‚úÖ –°–æ–∑–¥–∞—ë–º –ª–æ–∫–∞–ª—å–Ω—É—é –∫–æ–ø–∏—é –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏, –Ω–µ –∑–∞—Ç—Ä–∞–≥–∏–≤–∞–µ–º –∏—Å—Ö–æ–¥–Ω—ã–π –º–∞—Å—Å–∏–≤ –∏–∑ –ë–î
    let currentImageUrls = [...validImageUrls];
    
    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
      try {
        console.log(`üì§ [QStash] Attempt ${attempt}/${MAX_RETRIES} to send to Telegram`);

        // Split images into chunks of 10 (Telegram limit)
        const CHUNK_SIZE = 10;
        const imageChunks: string[][] = [];
        
        for (let i = 0; i < currentImageUrls.length; i += CHUNK_SIZE) {
          imageChunks.push(currentImageUrls.slice(i, i + CHUNK_SIZE));
        }

        console.log(`Divided ${currentImageUrls.length} images into ${imageChunks.length} chunks`);

        // Send first chunk with caption
        const firstChunk = imageChunks[0];
        const mediaGroup = firstChunk.map((url, index) => ({
          type: 'photo',
          media: url,
          ...(index === 0 ? { caption } : {})
        }));

        // Log URLs being sent to Telegram for debugging
        console.log(`üì∏ [QStash] Sending ${mediaGroup.length} images to Telegram:`);
        mediaGroup.forEach((m, i) => {
          console.log(`  [${i}] ${m.media.substring(0, 120)}${m.media.length > 120 ? '...' : ''}`);
        });

        const response = await fetch(
          `https://api.telegram.org/bot${TG_BOT_TOKEN}/sendMediaGroup`,
          {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              chat_id: TG_CHAT_ID,
              media: mediaGroup
            })
          }
        );

        if (!response.ok) {
          // –ü–∞—Ä—Å–∏–º retry_after –∏–∑ Telegram –æ—Ç–≤–µ—Ç–∞
          const errorData = await response.json().catch(() => ({}));
          const retryAfter = errorData.retry_after || 0;
          lastRetryAfter = retryAfter; // ‚úÖ –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ retry loop

          // Detailed error logging for debugging
          console.error(`‚ùå [Telegram] API error ${response.status}:`, {
            status: response.status,
            statusText: response.statusText,
            error_description: errorData.description || 'No description',
            error_code: errorData.error_code,
            parameters: errorData.parameters,
            retry_after: retryAfter,
            full_error: JSON.stringify(errorData)
          });

          // ‚úÖ –°–ü–ï–¶–ò–ê–õ–¨–ù–ê–Ø –û–ë–†–ê–ë–û–¢–ö–ê: WEBPAGE_MEDIA_EMPTY (–æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ü–ï–†–í–û–ô)
          if (response.status === 400 && errorData.description?.includes('WEBPAGE_MEDIA_EMPTY')) {
            const failedIndex = parseFailedImageIndex(errorData.description);
            
            console.warn(`‚ö†Ô∏è [Telegram] Image not accessible at index ${failedIndex}`);
            
            if (failedIndex !== null && failedIndex < currentImageUrls.length) {
              const removedUrl = currentImageUrls[failedIndex];
              console.log(`üóëÔ∏è [QStash] Removing inaccessible image: ${removedUrl}`);
              
              // ‚úÖ –£–¥–∞–ª—è–µ–º —Ç–æ–ª—å–∫–æ –∏–∑ –õ–û–ö–ê–õ–¨–ù–û–ô –∫–æ–ø–∏–∏, –Ω–µ –∏–∑ –ë–î
              currentImageUrls.splice(failedIndex, 1);
              
              // –õ–æ–≥–∏—Ä—É–µ–º —É–¥–∞–ª–µ–Ω–∏–µ –¥–ª—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∏
              await supabaseClient.from('telegram_notifications_log').insert({
                function_name: 'upstash-repost-handler',
                notification_type: `${notificationType}_image_skipped`,
                recipient_type: 'system',
                recipient_identifier: 'validation',
                message_text: `Skipped inaccessible image for product ${productId}`,
                status: 'warning',
                error_details: {
                  product_id: productId,
                  skipped_url: removedUrl,
                  failed_index: failedIndex,
                  remaining_images: currentImageUrls.length,
                  original_image_count: validImageUrls.length,
                  error: errorData.description
                },
                related_entity_type: 'product',
                related_entity_id: productId
              });
              
              if (currentImageUrls.length > 0) {
                console.log(`üîÑ [QStash] Retrying IMMEDIATELY with ${currentImageUrls.length}/${validImageUrls.length} images`);
                attempt--; // –ù–µ –∑–∞—Å—á–∏—Ç—ã–≤–∞–µ–º –∫–∞–∫ –ø–æ–ø—ã—Ç–∫—É
                continue; // ‚úÖ –ü–æ–≤—Ç–æ—Ä—è–µ–º –°–†–ê–ó–£ –±–µ–∑ –∑–∞–¥–µ—Ä–∂–∫–∏
              } else {
                throw new Error('No valid images remaining after filtering');
              }
            }
            
            // ‚úÖ –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å, –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å –æ–±—ã—á–Ω–æ–π –æ—à–∏–±–∫–æ–π
            console.error(`‚ùå [WEBPAGE_MEDIA_EMPTY] Could not parse failed image index, treating as regular error`);
          }

          // ‚úÖ –°–ü–ï–¶–ò–ê–õ–¨–ù–ê–Ø –û–ë–†–ê–ë–û–¢–ö–ê: Rate limit (429)
          if (response.status === 429) {
            console.warn(`‚ö†Ô∏è [Telegram] Rate limit hit (429) on attempt ${attempt}, retry_after: ${retryAfter}s`);
            
            // –õ–æ–≥–∏—Ä—É–µ–º –≤ –ë–î –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
            try {
              await supabaseClient.from('telegram_notifications_log').insert({
                function_name: 'upstash-repost-handler',
                notification_type: `${notificationType}_rate_limit`,
                recipient_type: 'group',
                recipient_identifier: TG_CHAT_ID || 'unknown',
                message_text: `Rate limit for product ${productId} (${notificationType})`,
                status: 'failed',
                error_details: { 
                  retry_after: retryAfter, // ‚úÖ –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
                  attempt, 
                  status: response.status, 
                  notification_type: notificationType,
                  description: errorData.description
                },
                related_entity_type: 'product',
                related_entity_id: productId
              });
            } catch (logError) {
              console.error('‚ö†Ô∏è Failed to log rate limit:', logError);
            }
          }

          const errorText = await response.text().catch(() => `Status ${response.status}`);
          throw new Error(`Telegram API error (${response.status}): ${errorText}`);
        }

        console.log(`‚úÖ [QStash] Successfully sent chunk 1 with ${firstChunk.length} images`);

        // Send remaining chunks
        for (let i = 1; i < imageChunks.length; i++) {
          const chunk = imageChunks[i];
          const chunkMediaGroup = chunk.map(url => ({
            type: 'photo',
            media: url
          }));

          const chunkResponse = await fetch(
            `https://api.telegram.org/bot${TG_BOT_TOKEN}/sendMediaGroup`,
            {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                chat_id: TG_CHAT_ID,
                media: chunkMediaGroup
              })
            }
          );

          if (!chunkResponse.ok) {
            const errorText = await chunkResponse.text();
            console.warn(`‚ö†Ô∏è [QStash] Failed to send chunk ${i + 1}: ${errorText}`);
          } else {
            console.log(`‚úÖ [QStash] Successfully sent chunk ${i + 1} with ${chunk.length} images`);
          }

          // Small delay between chunks
          await new Promise(resolve => setTimeout(resolve, 100));
        }

        console.log(`‚úÖ [QStash] Product ${productId} notification sent successfully on attempt ${attempt}`);

        // Update product notification timestamp and status
        try {
          await supabaseClient
            .from('products')
            .update({ 
              last_notification_sent_at: new Date().toISOString(),
              telegram_notification_status: 'sent'
              // catalog_position —É–∂–µ –æ–±–Ω–æ–≤–ª–µ–Ω –Ω–∞ frontend –≤ useProductRepost
            })
            .eq('id', productId);

          console.log(`‚úÖ [QStash] Updated last_notification_sent_at for product ${productId}`);
          
          // Log successful notification to telegram_notifications_log
          await supabaseClient.from('telegram_notifications_log').insert({
            function_name: 'upstash-repost-handler',
            notification_type: notificationType,
            recipient_type: 'group',
            recipient_identifier: TG_CHAT_ID || 'unknown',
            message_text: caption.substring(0, 500), // First 500 chars
            status: 'sent',
            related_entity_type: 'product',
            related_entity_id: productId,
            metadata: {
              attempt,
              image_count: currentImageUrls.length,
              images_original: validImageUrls.length,
              images_skipped: validImageUrls.length - currentImageUrls.length,
              price_changed: priceChanged,
              new_price: newPrice,
              old_price: oldPrice,
              notification_type: notificationType
            }
          });
          
          console.log(`‚úÖ [QStash] Logged successful ${notificationType} notification to telegram_notifications_log`);
        } catch (dbError) {
          console.error('‚ö†Ô∏è [QStash] Failed to update product or log repost:', dbError);
          // –ù–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—à–∏–±–∫—É, —Ç–∞–∫ –∫–∞–∫ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –±—ã–ª–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ
        }

        return new Response(
          JSON.stringify({ success: true, attempt }),
          { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        );

      } catch (error) {
        lastError = error;
        console.error(`‚ùå [QStash] Attempt ${attempt} failed:`, error);
        
        if (attempt < MAX_RETRIES) {
          // ‚úÖ FIX: –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ retry_after
          const retryAfter = lastRetryAfter || 0;
          
          // –ò—Å–ø–æ–ª—å–∑—É–µ–º retry_after –∏–∑ Telegram –∏–ª–∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π backoff
          const baseDelay = Math.pow(2, attempt - 1) * 1000; // 1s, 2s, 4s
          const telegramDelay = retryAfter * 1000;
          const delay = Math.min(Math.max(telegramDelay, baseDelay), 10000); // –ú–∞–∫—Å–∏–º—É–º 10 —Å–µ–∫—É–Ω–¥

          console.log(`üîÑ [QStash] Retrying in ${delay}ms (attempt ${attempt}/${MAX_RETRIES})`);
          console.log(`   - Telegram retry_after: ${retryAfter}s`);
          console.log(`   - Base exponential: ${baseDelay}ms`);
          console.log(`   - Final delay: ${delay}ms`);
          
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }

    console.error(`üí• [QStash] All ${MAX_RETRIES} attempts exhausted for product ${productId}`);
    
    // ‚úÖ –õ–æ–≥–∏—Ä—É–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π —Å–±–æ–π –≤ telegram_notifications_log
    try {
      await supabaseClient.from('telegram_notifications_log').insert({
        function_name: 'upstash-repost-handler',
        notification_type: `${notificationType}_all_retries_failed`,
        recipient_type: 'group',
        recipient_identifier: TG_CHAT_ID || 'unknown',
        message_text: `All retries exhausted for product ${productId}`,
        status: 'failed',
        error_details: { 
          last_error: lastError?.message || 'Unknown error',
          total_attempts: MAX_RETRIES,
          last_retry_after: lastRetryAfter,
          images_sent: currentImageUrls.length,
          images_original: validImageUrls.length,
          images_skipped: validImageUrls.length - currentImageUrls.length
        },
        related_entity_type: 'product',
        related_entity_id: productId
      });
    } catch (logError) {
      console.error('‚ö†Ô∏è Failed to log final failure:', logError);
    }
    
    return new Response(
      JSON.stringify({ error: 'All retry attempts failed', lastError: lastError?.message }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 500 }
    );

  } catch (error) {
    console.error('üí• [QStash] Handler error:', error);
    return new Response(
      JSON.stringify({ error: error.message }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' }, status: 500 }
    );
  }
});
